// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Resolvers
{
    using System;
    using UnityEngine;

    public class GeneratedResolver : global::MessagePack.IFormatterResolver
    {
        public static readonly global::MessagePack.IFormatterResolver Instance = new GeneratedResolver();

        private GeneratedResolver()
        {
        }

        public global::MessagePack.Formatters.IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            internal static readonly global::MessagePack.Formatters.IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                var f = GeneratedResolverGetFormatterHelper.GetFormatter(typeof(T));
                if (f != null)
                {
                    Formatter = (global::MessagePack.Formatters.IMessagePackFormatter<T>)f;
                }
            }
        }
    }

    internal static class GeneratedResolverGetFormatterHelper
    {
        private static readonly global::System.Collections.Generic.Dictionary<Type, int> lookup;

        static GeneratedResolverGetFormatterHelper()
        {
            lookup = new global::System.Collections.Generic.Dictionary<Type, int>(39)
            {
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<bool>), 0 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<byte>), 1 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Color32>), 2 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<double>), 3 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<float[]>), 4 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<float>), 5 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.ParentInfo>), 6 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.TrInfo>), 7 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid[]>), 8 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid>), 9 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<int>), 10 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<long>), 11 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<string[]>), 12 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<string>), 13 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector2[]>), 14 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector2>), 15 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector3[]>), 16 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector3>), 17 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector4[]>), 18 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector4>), 19 },
                { typeof(global::System.Collections.Generic.Dictionary<string, global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper>), 20 },
                { typeof(global::System.Collections.Generic.List<global::ShapesXr.Import.Core.IEdit>), 21 },
                { typeof(global::System.Guid[]), 22 },
                { typeof(Vector2[]), 23 },
                { typeof(Vector3[]), 24 },
                { typeof(Vector4[]), 25 },
                { typeof(global::ShapesXr.Import.Core.IEdit), 26 },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper), 27 },
                { typeof(global::ShapesXr.Import.Core.CreationEdit), 28 },
                { typeof(global::ShapesXr.Import.Core.ParentInfo), 29 },
                { typeof(global::ShapesXr.Import.Core.PropertyEdits), 30 },
                { typeof(global::ShapesXr.Import.Core.SpaceEdition), 31 },
                { typeof(global::ShapesXr.Import.Core.SpaceInfo), 32 },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty), 33 },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty), 34 },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.IntProperty), 35 },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.Properties), 36 },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty), 37 },
                { typeof(global::ShapesXr.Import.Core.TrInfo), 38 },
            };
        }

        internal static object GetFormatter(Type t)
        {
            int key;
            if (!lookup.TryGetValue(t, out key))
            {
                return null;
            }

            switch (key)
            {
                case 0: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<bool>();
                case 1: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<byte>();
                case 2: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<Color32>();
                case 3: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<double>();
                case 4: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<float[]>();
                case 5: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<float>();
                case 6: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<global::ShapesXr.Import.Core.ParentInfo>();
                case 7: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<global::ShapesXr.Import.Core.TrInfo>();
                case 8: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<global::System.Guid[]>();
                case 9: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<global::System.Guid>();
                case 10: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<int>();
                case 11: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<long>();
                case 12: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<string[]>();
                case 13: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<string>();
                case 14: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<Vector2[]>();
                case 15: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<Vector2>();
                case 16: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<Vector3[]>();
                case 17: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<Vector3>();
                case 18: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<Vector4[]>();
                case 19: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditFormatter<Vector4>();
                case 20: return new global::MessagePack.Formatters.DictionaryFormatter<string, global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper>();
                case 21: return new global::MessagePack.Formatters.ListFormatter<global::ShapesXr.Import.Core.IEdit>();
                case 22: return new global::MessagePack.Formatters.ArrayFormatter<global::System.Guid>();
                case 23: return new global::MessagePack.Formatters.ArrayFormatter<Vector2>();
                case 24: return new global::MessagePack.Formatters.ArrayFormatter<Vector3>();
                case 25: return new global::MessagePack.Formatters.ArrayFormatter<Vector4>();
                case 26: return new ShapesXR.Formatters.ShapesXr.Import.Core.IEditFormatter();
                case 27: return new ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapperFormatter();
                case 28: return new ShapesXR.Formatters.ShapesXr.Import.Core.CreationEditFormatter();
                case 29: return new ShapesXR.Formatters.ShapesXr.Import.Core.ParentInfoFormatter();
                case 30: return new ShapesXR.Formatters.ShapesXr.Import.Core.PropertyEditsFormatter();
                case 31: return new ShapesXR.Formatters.ShapesXr.Import.Core.SpaceEditionFormatter();
                case 32: return new ShapesXR.Formatters.ShapesXr.Import.Core.SpaceInfoFormatter();
                case 33: return new ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer.ColorPropertyFormatter();
                case 34: return new ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer.FloatPropertyFormatter();
                case 35: return new ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer.IntPropertyFormatter();
                case 36: return new ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer.PropertiesFormatter();
                case 37: return new ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer.TexturePropertyFormatter();
                case 38: return new ShapesXR.Formatters.ShapesXr.Import.Core.TrInfoFormatter();
                default: return null;
            }
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core
{
    using System;
    using System.Buffers;
    using MessagePack;
    using UnityEngine;

    public sealed class TrInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.TrInfo>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.TrInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(3);
            formatterResolver.GetFormatterWithVerify<Vector3>().Serialize(ref writer, value.localPosition, options);
            formatterResolver.GetFormatterWithVerify<Quaternion>().Serialize(ref writer, value.localRotation, options);
            formatterResolver.GetFormatterWithVerify<Vector3>().Serialize(ref writer, value.localScale, options);
        }

        public global::ShapesXr.Import.Core.TrInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __localPosition__ = default(Vector3);
            var __localRotation__ = default(Quaternion);
            var __localScale__ = default(Vector3);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __localPosition__ = formatterResolver.GetFormatterWithVerify<Vector3>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __localRotation__ = formatterResolver.GetFormatterWithVerify<Quaternion>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __localScale__ = formatterResolver.GetFormatterWithVerify<Vector3>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.TrInfo(__localPosition__, __localRotation__, __localScale__);
            ____result.localPosition = __localPosition__;
            ____result.localRotation = __localRotation__;
            ____result.localScale = __localScale__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer
{
    using System;
    using System.Buffers;
    using MessagePack;
    using UnityEngine;

    public sealed class TexturePropertyFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(6);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.UIName, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropertyName, options);
            writer.Write(value.IsInPropertyBlock);
            formatterResolver.GetFormatterWithVerify<Texture>().Serialize(ref writer, value.Value, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropType, options);
        }

        public global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __UIName__ = default(string);
            var __PropertyName__ = default(string);
            var __IsInPropertyBlock__ = default(bool);
            var __Value__ = default(Texture);
            var __PropType__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __UIName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __PropertyName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __IsInPropertyBlock__ = reader.ReadBoolean();
                        break;
                    case 4:
                        __Value__ = formatterResolver.GetFormatterWithVerify<Texture>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __PropType__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty();
            ____result.Name = __Name__;
            ____result.UIName = __UIName__;
            ____result.PropertyName = __PropertyName__;
            ____result.IsInPropertyBlock = __IsInPropertyBlock__;
            ____result.Value = __Value__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class PropertyWrapperFormatter<T> : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.Tools.Materializer.PropertyWrapper<T>>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.Tools.Materializer.PropertyWrapper<T> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(6);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.UIName, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropertyName, options);
            writer.Write(value.IsInPropertyBlock);
            formatterResolver.GetFormatterWithVerify<T>().Serialize(ref writer, value.Value, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropType, options);
        }

        public global::ShapesXr.Import.Core.Tools.Materializer.PropertyWrapper<T> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __UIName__ = default(string);
            var __PropertyName__ = default(string);
            var __IsInPropertyBlock__ = default(bool);
            var __Value__ = default(T);
            var __PropType__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __UIName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __PropertyName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __IsInPropertyBlock__ = reader.ReadBoolean();
                        break;
                    case 4:
                        __Value__ = formatterResolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __PropType__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.Tools.Materializer.PropertyWrapper<T>();
            ____result.Name = __Name__;
            ____result.UIName = __UIName__;
            ____result.PropertyName = __PropertyName__;
            ____result.IsInPropertyBlock = __IsInPropertyBlock__;
            ____result.Value = __Value__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class PropertiesFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.Tools.Materializer.Properties>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.Tools.Materializer.Properties value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(1);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.Dictionary<string, global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper>>().Serialize(ref writer, value.PropertyDict, options);
        }

        public global::ShapesXr.Import.Core.Tools.Materializer.Properties Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __PropertyDict__ = default(global::System.Collections.Generic.Dictionary<string, global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __PropertyDict__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.Dictionary<string, global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.Tools.Materializer.Properties();
            ____result.PropertyDict = __PropertyDict__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer
{
    using System;
    using System.Buffers;
    using System.Collections.Generic;
    using MessagePack;

    public sealed class IPropertyWrapperFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper>
    {
        private readonly Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>> typeToKeyAndJumpMap;
        private readonly Dictionary<int, int> keyToJumpMap;

        public IPropertyWrapperFormatter()
        {
            this.typeToKeyAndJumpMap = new Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>(4, global::MessagePack.Internal.RuntimeTypeHandleEqualityComparer.Default)
            {
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty).TypeHandle, new KeyValuePair<int, int>(0, 0) },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty).TypeHandle, new KeyValuePair<int, int>(1, 1) },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.IntProperty).TypeHandle, new KeyValuePair<int, int>(2, 2) },
                { typeof(global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty).TypeHandle, new KeyValuePair<int, int>(3, 3) },
            };
            this.keyToJumpMap = new Dictionary<int, int>(4)
            {
                { 0, 0 },
                { 1, 1 },
                { 2, 2 },
                { 3, 3 },
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper value, global::MessagePack.MessagePackSerializerOptions options)
        {
            KeyValuePair<int, int> keyValuePair;
            if (value != null && this.typeToKeyAndJumpMap.TryGetValue(value.GetType().TypeHandle, out keyValuePair))
            {
                writer.WriteArrayHeader(2);
                writer.WriteInt32(keyValuePair.Key);
                switch (keyValuePair.Value)
                {
                    case 0:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty>().Serialize(ref writer, (global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty)value, options);
                        break;
                    case 1:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty>().Serialize(ref writer, (global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty)value, options);
                        break;
                    case 2:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.Tools.Materializer.IntProperty>().Serialize(ref writer, (global::ShapesXr.Import.Core.Tools.Materializer.IntProperty)value, options);
                        break;
                    case 3:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty>().Serialize(ref writer, (global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty)value, options);
                        break;
                    default:
                        break;
                }

                return;
            }

            writer.WriteNil();
        }

        public global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            if (reader.ReadArrayHeader() != 2)
            {
                throw new InvalidOperationException("Invalid Union data was detected. Type:global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper");
            }

            options.Security.DepthStep(ref reader);
            var key = reader.ReadInt32();

            if (!this.keyToJumpMap.TryGetValue(key, out key))
            {
                key = -1;
            }

            global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper result = null;
            switch (key)
            {
                case 0:
                    result = (global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty>().Deserialize(ref reader, options);
                    break;
                case 1:
                    result = (global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty>().Deserialize(ref reader, options);
                    break;
                case 2:
                    result = (global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.Tools.Materializer.IntProperty>().Deserialize(ref reader, options);
                    break;
                case 3:
                    result = (global::ShapesXr.Import.Core.Tools.Materializer.IPropertyWrapper)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.Tools.Materializer.TextureProperty>().Deserialize(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }

            reader.Depth--;
            return result;
        }
    }


}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class IntPropertyFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.Tools.Materializer.IntProperty>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.Tools.Materializer.IntProperty value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(6);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.UIName, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropertyName, options);
            writer.Write(value.IsInPropertyBlock);
            writer.Write(value.Value);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropType, options);
        }

        public global::ShapesXr.Import.Core.Tools.Materializer.IntProperty Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __UIName__ = default(string);
            var __PropertyName__ = default(string);
            var __IsInPropertyBlock__ = default(bool);
            var __Value__ = default(int);
            var __PropType__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __UIName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __PropertyName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __IsInPropertyBlock__ = reader.ReadBoolean();
                        break;
                    case 4:
                        __Value__ = reader.ReadInt32();
                        break;
                    case 5:
                        __PropType__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.Tools.Materializer.IntProperty();
            ____result.Name = __Name__;
            ____result.UIName = __UIName__;
            ____result.PropertyName = __PropertyName__;
            ____result.IsInPropertyBlock = __IsInPropertyBlock__;
            ____result.Value = __Value__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class FloatPropertyFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(6);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.UIName, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropertyName, options);
            writer.Write(value.IsInPropertyBlock);
            writer.Write(value.Value);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropType, options);
        }

        public global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __UIName__ = default(string);
            var __PropertyName__ = default(string);
            var __IsInPropertyBlock__ = default(bool);
            var __Value__ = default(float);
            var __PropType__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __UIName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __PropertyName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __IsInPropertyBlock__ = reader.ReadBoolean();
                        break;
                    case 4:
                        __Value__ = reader.ReadSingle();
                        break;
                    case 5:
                        __PropType__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.Tools.Materializer.FloatProperty();
            ____result.Name = __Name__;
            ____result.UIName = __UIName__;
            ____result.PropertyName = __PropertyName__;
            ____result.IsInPropertyBlock = __IsInPropertyBlock__;
            ____result.Value = __Value__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core.Tools.Materializer
{
    using System;
    using System.Buffers;
    using MessagePack;
    using UnityEngine;

    public sealed class ColorPropertyFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(6);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.UIName, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropertyName, options);
            writer.Write(value.IsInPropertyBlock);
            formatterResolver.GetFormatterWithVerify<Color>().Serialize(ref writer, value.Value, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropType, options);
        }

        public global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __UIName__ = default(string);
            var __PropertyName__ = default(string);
            var __IsInPropertyBlock__ = default(bool);
            var __Value__ = default(Color);
            var __PropType__ = default(string);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __UIName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __PropertyName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __IsInPropertyBlock__ = reader.ReadBoolean();
                        break;
                    case 4:
                        __Value__ = formatterResolver.GetFormatterWithVerify<Color>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __PropType__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.Tools.Materializer.ColorProperty();
            ____result.Name = __Name__;
            ____result.UIName = __UIName__;
            ____result.PropertyName = __PropertyName__;
            ____result.IsInPropertyBlock = __IsInPropertyBlock__;
            ____result.Value = __Value__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class SpaceInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.SpaceInfo>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.SpaceInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.SpaceEdition>().Serialize(ref writer, value.Edition, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::ShapesXr.Import.Core.IEdit>>().Serialize(ref writer, value.Edits, options);
        }

        public global::ShapesXr.Import.Core.SpaceInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Edition__ = default(global::ShapesXr.Import.Core.SpaceEdition);
            var __Edits__ = default(global::System.Collections.Generic.List<global::ShapesXr.Import.Core.IEdit>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Edition__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.SpaceEdition>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Edits__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::ShapesXr.Import.Core.IEdit>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.SpaceInfo();
            ____result.Edition = __Edition__;
            ____result.Edits = __Edits__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class SpaceEditionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.SpaceEdition>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.SpaceEdition value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.Write(value.Compressions);
            writer.Write(value.Edits);
        }

        public global::ShapesXr.Import.Core.SpaceEdition Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __Compressions__ = default(int);
            var __Edits__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Compressions__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Edits__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.SpaceEdition(__Compressions__, __Edits__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core
{
    using System;
    using System.Buffers;
    using MessagePack;
    using UnityEngine;

    public sealed class PropertyEditsFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.PropertyEdits>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.PropertyEdits value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(20);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<bool>>().Serialize(ref writer, value.Bool, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<int>>().Serialize(ref writer, value.Int, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<float>>().Serialize(ref writer, value.Float, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<long>>().Serialize(ref writer, value.Long, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<double>>().Serialize(ref writer, value.Double, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<string>>().Serialize(ref writer, value.String, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector2>>().Serialize(ref writer, value.Vector2, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector3>>().Serialize(ref writer, value.Vector3, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector4>>().Serialize(ref writer, value.Vector4, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.TrInfo>>().Serialize(ref writer, value.TrInfo, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<float[]>>().Serialize(ref writer, value.FloatArray, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector2[]>>().Serialize(ref writer, value.Vector2Array, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector3[]>>().Serialize(ref writer, value.Vector3Array, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector4[]>>().Serialize(ref writer, value.Vector4Array, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Color32>>().Serialize(ref writer, value.Color32, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<byte>>().Serialize(ref writer, value.Byte, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid>>().Serialize(ref writer, value.Guid, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid[]>>().Serialize(ref writer, value.GuidArray, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<string[]>>().Serialize(ref writer, value.StringArray, options);
            formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.ParentInfo>>().Serialize(ref writer, value.ParentInfo, options);
        }

        public global::ShapesXr.Import.Core.PropertyEdits Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Bool__ = default(global::ShapesXr.Import.Core.PropertyEdit<bool>);
            var __Int__ = default(global::ShapesXr.Import.Core.PropertyEdit<int>);
            var __Float__ = default(global::ShapesXr.Import.Core.PropertyEdit<float>);
            var __Long__ = default(global::ShapesXr.Import.Core.PropertyEdit<long>);
            var __Double__ = default(global::ShapesXr.Import.Core.PropertyEdit<double>);
            var __String__ = default(global::ShapesXr.Import.Core.PropertyEdit<string>);
            var __Vector2__ = default(global::ShapesXr.Import.Core.PropertyEdit<Vector2>);
            var __Vector3__ = default(global::ShapesXr.Import.Core.PropertyEdit<Vector3>);
            var __Vector4__ = default(global::ShapesXr.Import.Core.PropertyEdit<Vector4>);
            var __TrInfo__ = default(global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.TrInfo>);
            var __FloatArray__ = default(global::ShapesXr.Import.Core.PropertyEdit<float[]>);
            var __Vector2Array__ = default(global::ShapesXr.Import.Core.PropertyEdit<Vector2[]>);
            var __Vector3Array__ = default(global::ShapesXr.Import.Core.PropertyEdit<Vector3[]>);
            var __Vector4Array__ = default(global::ShapesXr.Import.Core.PropertyEdit<Vector4[]>);
            var __Color32__ = default(global::ShapesXr.Import.Core.PropertyEdit<Color32>);
            var __Byte__ = default(global::ShapesXr.Import.Core.PropertyEdit<byte>);
            var __Guid__ = default(global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid>);
            var __GuidArray__ = default(global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid[]>);
            var __StringArray__ = default(global::ShapesXr.Import.Core.PropertyEdit<string[]>);
            var __ParentInfo__ = default(global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.ParentInfo>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __Bool__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<bool>>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Int__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<int>>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Float__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<float>>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Long__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<long>>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Double__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<double>>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __String__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<string>>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Vector2__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector2>>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Vector3__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector3>>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Vector4__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector4>>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __TrInfo__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.TrInfo>>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __FloatArray__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<float[]>>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Vector2Array__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector2[]>>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Vector3Array__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector3[]>>().Deserialize(ref reader, options);
                        break;
                    case 13:
                        __Vector4Array__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector4[]>>().Deserialize(ref reader, options);
                        break;
                    case 14:
                        __Color32__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Color32>>().Deserialize(ref reader, options);
                        break;
                    case 15:
                        __Byte__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<byte>>().Deserialize(ref reader, options);
                        break;
                    case 16:
                        __Guid__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid>>().Deserialize(ref reader, options);
                        break;
                    case 17:
                        __GuidArray__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid[]>>().Deserialize(ref reader, options);
                        break;
                    case 18:
                        __StringArray__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<string[]>>().Deserialize(ref reader, options);
                        break;
                    case 19:
                        __ParentInfo__ = formatterResolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.ParentInfo>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.PropertyEdits();
            ____result.Bool = __Bool__;
            ____result.Int = __Int__;
            ____result.Float = __Float__;
            ____result.Long = __Long__;
            ____result.Double = __Double__;
            ____result.String = __String__;
            ____result.Vector2 = __Vector2__;
            ____result.Vector3 = __Vector3__;
            ____result.Vector4 = __Vector4__;
            ____result.TrInfo = __TrInfo__;
            ____result.FloatArray = __FloatArray__;
            ____result.Vector2Array = __Vector2Array__;
            ____result.Vector3Array = __Vector3Array__;
            ____result.Vector4Array = __Vector4Array__;
            ____result.Color32 = __Color32__;
            ____result.Byte = __Byte__;
            ____result.Guid = __Guid__;
            ____result.GuidArray = __GuidArray__;
            ____result.StringArray = __StringArray__;
            ____result.ParentInfo = __ParentInfo__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class PropertyEditFormatter<T> : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.PropertyEdit<T>>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.PropertyEdit<T> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(3);
            formatterResolver.GetFormatterWithVerify<global::System.Guid>().Serialize(ref writer, value.ObjectId, options);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.PropName, options);
            formatterResolver.GetFormatterWithVerify<T>().Serialize(ref writer, value.Value, options);
        }

        public global::ShapesXr.Import.Core.PropertyEdit<T> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __ObjectId__ = default(global::System.Guid);
            var __PropName__ = default(string);
            var __Value__ = default(T);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __ObjectId__ = formatterResolver.GetFormatterWithVerify<global::System.Guid>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __PropName__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Value__ = formatterResolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.PropertyEdit<T>(__ObjectId__, __PropName__, __Value__);
            ____result.ObjectId = __ObjectId__;
            ____result.Value = __Value__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class ParentInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.ParentInfo>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.ParentInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            formatterResolver.GetFormatterWithVerify<global::System.Guid>().Serialize(ref writer, value.parentId, options);
            writer.Write(value.linked);
        }

        public global::ShapesXr.Import.Core.ParentInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __parentId__ = default(global::System.Guid);
            var __linked__ = default(bool);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __parentId__ = formatterResolver.GetFormatterWithVerify<global::System.Guid>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __linked__ = reader.ReadBoolean();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.ParentInfo(__parentId__, __linked__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core
{
    using System;
    using System.Buffers;
    using System.Collections.Generic;
    using MessagePack;
    using UnityEngine;

    public sealed class IEditFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.IEdit>
    {
        private readonly Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>> typeToKeyAndJumpMap;
        private readonly Dictionary<int, int> keyToJumpMap;

        public IEditFormatter()
        {
            this.typeToKeyAndJumpMap = new Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>(21, global::MessagePack.Internal.RuntimeTypeHandleEqualityComparer.Default)
            {
                { typeof(global::ShapesXr.Import.Core.CreationEdit).TypeHandle, new KeyValuePair<int, int>(0, 0) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<bool>).TypeHandle, new KeyValuePair<int, int>(1, 1) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<int>).TypeHandle, new KeyValuePair<int, int>(2, 2) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<float>).TypeHandle, new KeyValuePair<int, int>(3, 3) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<long>).TypeHandle, new KeyValuePair<int, int>(4, 4) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<double>).TypeHandle, new KeyValuePair<int, int>(5, 5) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<string>).TypeHandle, new KeyValuePair<int, int>(6, 6) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector2>).TypeHandle, new KeyValuePair<int, int>(7, 7) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector3>).TypeHandle, new KeyValuePair<int, int>(8, 8) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector4>).TypeHandle, new KeyValuePair<int, int>(9, 9) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.TrInfo>).TypeHandle, new KeyValuePair<int, int>(10, 10) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<float[]>).TypeHandle, new KeyValuePair<int, int>(11, 11) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector2[]>).TypeHandle, new KeyValuePair<int, int>(12, 12) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector3[]>).TypeHandle, new KeyValuePair<int, int>(13, 13) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Vector4[]>).TypeHandle, new KeyValuePair<int, int>(14, 14) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<byte>).TypeHandle, new KeyValuePair<int, int>(15, 15) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<Color32>).TypeHandle, new KeyValuePair<int, int>(16, 16) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid>).TypeHandle, new KeyValuePair<int, int>(17, 17) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid[]>).TypeHandle, new KeyValuePair<int, int>(18, 18) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<string[]>).TypeHandle, new KeyValuePair<int, int>(19, 19) },
                { typeof(global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.ParentInfo>).TypeHandle, new KeyValuePair<int, int>(20, 20) },
            };
            this.keyToJumpMap = new Dictionary<int, int>(21)
            {
                { 0, 0 },
                { 1, 1 },
                { 2, 2 },
                { 3, 3 },
                { 4, 4 },
                { 5, 5 },
                { 6, 6 },
                { 7, 7 },
                { 8, 8 },
                { 9, 9 },
                { 10, 10 },
                { 11, 11 },
                { 12, 12 },
                { 13, 13 },
                { 14, 14 },
                { 15, 15 },
                { 16, 16 },
                { 17, 17 },
                { 18, 18 },
                { 19, 19 },
                { 20, 20 },
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.IEdit value, global::MessagePack.MessagePackSerializerOptions options)
        {
            KeyValuePair<int, int> keyValuePair;
            if (value != null && this.typeToKeyAndJumpMap.TryGetValue(value.GetType().TypeHandle, out keyValuePair))
            {
                writer.WriteArrayHeader(2);
                writer.WriteInt32(keyValuePair.Key);
                switch (keyValuePair.Value)
                {
                    case 0:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.CreationEdit>().Serialize(ref writer, (global::ShapesXr.Import.Core.CreationEdit)value, options);
                        break;
                    case 1:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<bool>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<bool>)value, options);
                        break;
                    case 2:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<int>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<int>)value, options);
                        break;
                    case 3:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<float>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<float>)value, options);
                        break;
                    case 4:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<long>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<long>)value, options);
                        break;
                    case 5:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<double>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<double>)value, options);
                        break;
                    case 6:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<string>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<string>)value, options);
                        break;
                    case 7:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector2>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<Vector2>)value, options);
                        break;
                    case 8:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector3>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<Vector3>)value, options);
                        break;
                    case 9:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector4>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<Vector4>)value, options);
                        break;
                    case 10:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.TrInfo>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.TrInfo>)value, options);
                        break;
                    case 11:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<float[]>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<float[]>)value, options);
                        break;
                    case 12:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector2[]>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<Vector2[]>)value, options);
                        break;
                    case 13:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector3[]>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<Vector3[]>)value, options);
                        break;
                    case 14:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector4[]>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<Vector4[]>)value, options);
                        break;
                    case 15:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<byte>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<byte>)value, options);
                        break;
                    case 16:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Color32>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<Color32>)value, options);
                        break;
                    case 17:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid>)value, options);
                        break;
                    case 18:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid[]>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid[]>)value, options);
                        break;
                    case 19:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<string[]>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<string[]>)value, options);
                        break;
                    case 20:
                        options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.ParentInfo>>().Serialize(ref writer, (global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.ParentInfo>)value, options);
                        break;
                    default:
                        break;
                }

                return;
            }

            writer.WriteNil();
        }

        public global::ShapesXr.Import.Core.IEdit Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            if (reader.ReadArrayHeader() != 2)
            {
                throw new InvalidOperationException("Invalid Union data was detected. Type:global::ShapesXr.Import.Core.IEdit");
            }

            options.Security.DepthStep(ref reader);
            var key = reader.ReadInt32();

            if (!this.keyToJumpMap.TryGetValue(key, out key))
            {
                key = -1;
            }

            global::ShapesXr.Import.Core.IEdit result = null;
            switch (key)
            {
                case 0:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.CreationEdit>().Deserialize(ref reader, options);
                    break;
                case 1:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<bool>>().Deserialize(ref reader, options);
                    break;
                case 2:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<int>>().Deserialize(ref reader, options);
                    break;
                case 3:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<float>>().Deserialize(ref reader, options);
                    break;
                case 4:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<long>>().Deserialize(ref reader, options);
                    break;
                case 5:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<double>>().Deserialize(ref reader, options);
                    break;
                case 6:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<string>>().Deserialize(ref reader, options);
                    break;
                case 7:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector2>>().Deserialize(ref reader, options);
                    break;
                case 8:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector3>>().Deserialize(ref reader, options);
                    break;
                case 9:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector4>>().Deserialize(ref reader, options);
                    break;
                case 10:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.TrInfo>>().Deserialize(ref reader, options);
                    break;
                case 11:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<float[]>>().Deserialize(ref reader, options);
                    break;
                case 12:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector2[]>>().Deserialize(ref reader, options);
                    break;
                case 13:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector3[]>>().Deserialize(ref reader, options);
                    break;
                case 14:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Vector4[]>>().Deserialize(ref reader, options);
                    break;
                case 15:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<byte>>().Deserialize(ref reader, options);
                    break;
                case 16:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<Color32>>().Deserialize(ref reader, options);
                    break;
                case 17:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid>>().Deserialize(ref reader, options);
                    break;
                case 18:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::System.Guid[]>>().Deserialize(ref reader, options);
                    break;
                case 19:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<string[]>>().Deserialize(ref reader, options);
                    break;
                case 20:
                    result = (global::ShapesXr.Import.Core.IEdit)options.Resolver.GetFormatterWithVerify<global::ShapesXr.Import.Core.PropertyEdit<global::ShapesXr.Import.Core.ParentInfo>>().Deserialize(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }

            reader.Depth--;
            return result;
        }
    }


}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name


// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace ShapesXR.Formatters.ShapesXr.Import.Core
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class CreationEditFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ShapesXr.Import.Core.CreationEdit>
    {

        public void Serialize(ref MessagePackWriter writer, global::ShapesXr.Import.Core.CreationEdit value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            formatterResolver.GetFormatterWithVerify<global::System.Guid>().Serialize(ref writer, value.ObjectId, options);
            writer.Write(value.IsCreating);
        }

        public global::ShapesXr.Import.Core.CreationEdit Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __ObjectId__ = default(global::System.Guid);
            var __IsCreating__ = default(bool);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __ObjectId__ = formatterResolver.GetFormatterWithVerify<global::System.Guid>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __IsCreating__ = reader.ReadBoolean();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::ShapesXr.Import.Core.CreationEdit(__ObjectId__, __IsCreating__);
            ____result.ObjectId = __ObjectId__;
            ____result.IsCreating = __IsCreating__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name
